// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

var (
	Q                      = new(Query)
	Actor                  *actor
	AppVersion             *appVersion
	Episode                *episode
	EpisodeAudioMapping    *episodeAudioMapping
	EpisodeSubtitleMapping *episodeSubtitleMapping
	User                   *user
	Video                  *video
	VideoActorMapping      *videoActorMapping
	VideoUserMapping       *videoUserMapping
)

func SetDefault(db *gorm.DB, opts ...gen.DOOption) {
	*Q = *Use(db, opts...)
	Actor = &Q.Actor
	AppVersion = &Q.AppVersion
	Episode = &Q.Episode
	EpisodeAudioMapping = &Q.EpisodeAudioMapping
	EpisodeSubtitleMapping = &Q.EpisodeSubtitleMapping
	User = &Q.User
	Video = &Q.Video
	VideoActorMapping = &Q.VideoActorMapping
	VideoUserMapping = &Q.VideoUserMapping
}

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:                     db,
		Actor:                  newActor(db, opts...),
		AppVersion:             newAppVersion(db, opts...),
		Episode:                newEpisode(db, opts...),
		EpisodeAudioMapping:    newEpisodeAudioMapping(db, opts...),
		EpisodeSubtitleMapping: newEpisodeSubtitleMapping(db, opts...),
		User:                   newUser(db, opts...),
		Video:                  newVideo(db, opts...),
		VideoActorMapping:      newVideoActorMapping(db, opts...),
		VideoUserMapping:       newVideoUserMapping(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	Actor                  actor
	AppVersion             appVersion
	Episode                episode
	EpisodeAudioMapping    episodeAudioMapping
	EpisodeSubtitleMapping episodeSubtitleMapping
	User                   user
	Video                  video
	VideoActorMapping      videoActorMapping
	VideoUserMapping       videoUserMapping
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:                     db,
		Actor:                  q.Actor.clone(db),
		AppVersion:             q.AppVersion.clone(db),
		Episode:                q.Episode.clone(db),
		EpisodeAudioMapping:    q.EpisodeAudioMapping.clone(db),
		EpisodeSubtitleMapping: q.EpisodeSubtitleMapping.clone(db),
		User:                   q.User.clone(db),
		Video:                  q.Video.clone(db),
		VideoActorMapping:      q.VideoActorMapping.clone(db),
		VideoUserMapping:       q.VideoUserMapping.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:                     db,
		Actor:                  q.Actor.replaceDB(db),
		AppVersion:             q.AppVersion.replaceDB(db),
		Episode:                q.Episode.replaceDB(db),
		EpisodeAudioMapping:    q.EpisodeAudioMapping.replaceDB(db),
		EpisodeSubtitleMapping: q.EpisodeSubtitleMapping.replaceDB(db),
		User:                   q.User.replaceDB(db),
		Video:                  q.Video.replaceDB(db),
		VideoActorMapping:      q.VideoActorMapping.replaceDB(db),
		VideoUserMapping:       q.VideoUserMapping.replaceDB(db),
	}
}

type queryCtx struct {
	Actor                  IActorDo
	AppVersion             IAppVersionDo
	Episode                IEpisodeDo
	EpisodeAudioMapping    IEpisodeAudioMappingDo
	EpisodeSubtitleMapping IEpisodeSubtitleMappingDo
	User                   IUserDo
	Video                  IVideoDo
	VideoActorMapping      IVideoActorMappingDo
	VideoUserMapping       IVideoUserMappingDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		Actor:                  q.Actor.WithContext(ctx),
		AppVersion:             q.AppVersion.WithContext(ctx),
		Episode:                q.Episode.WithContext(ctx),
		EpisodeAudioMapping:    q.EpisodeAudioMapping.WithContext(ctx),
		EpisodeSubtitleMapping: q.EpisodeSubtitleMapping.WithContext(ctx),
		User:                   q.User.WithContext(ctx),
		Video:                  q.Video.WithContext(ctx),
		VideoActorMapping:      q.VideoActorMapping.WithContext(ctx),
		VideoUserMapping:       q.VideoUserMapping.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
