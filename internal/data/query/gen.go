// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:                   db,
		Actor:                newActor(db, opts...),
		AppVersion:           newAppVersion(db, opts...),
		Episode:              newEpisode(db, opts...),
		Genre:                newGenre(db, opts...),
		Keyword:              newKeyword(db, opts...),
		Movie:                newMovie(db, opts...),
		Season:               newSeason(db, opts...),
		Series:               newSeries(db, opts...),
		Studio:               newStudio(db, opts...),
		User:                 newUser(db, opts...),
		VideoActorMapping:    newVideoActorMapping(db, opts...),
		VideoGenreMapping:    newVideoGenreMapping(db, opts...),
		VideoKeywordMapping:  newVideoKeywordMapping(db, opts...),
		VideoStudioMapping:   newVideoStudioMapping(db, opts...),
		VideoSubtitleMapping: newVideoSubtitleMapping(db, opts...),
		VideoUserMapping:     newVideoUserMapping(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	Actor                actor
	AppVersion           appVersion
	Episode              episode
	Genre                genre
	Keyword              keyword
	Movie                movie
	Season               season
	Series               series
	Studio               studio
	User                 user
	VideoActorMapping    videoActorMapping
	VideoGenreMapping    videoGenreMapping
	VideoKeywordMapping  videoKeywordMapping
	VideoStudioMapping   videoStudioMapping
	VideoSubtitleMapping videoSubtitleMapping
	VideoUserMapping     videoUserMapping
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:                   db,
		Actor:                q.Actor.clone(db),
		AppVersion:           q.AppVersion.clone(db),
		Episode:              q.Episode.clone(db),
		Genre:                q.Genre.clone(db),
		Keyword:              q.Keyword.clone(db),
		Movie:                q.Movie.clone(db),
		Season:               q.Season.clone(db),
		Series:               q.Series.clone(db),
		Studio:               q.Studio.clone(db),
		User:                 q.User.clone(db),
		VideoActorMapping:    q.VideoActorMapping.clone(db),
		VideoGenreMapping:    q.VideoGenreMapping.clone(db),
		VideoKeywordMapping:  q.VideoKeywordMapping.clone(db),
		VideoStudioMapping:   q.VideoStudioMapping.clone(db),
		VideoSubtitleMapping: q.VideoSubtitleMapping.clone(db),
		VideoUserMapping:     q.VideoUserMapping.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:                   db,
		Actor:                q.Actor.replaceDB(db),
		AppVersion:           q.AppVersion.replaceDB(db),
		Episode:              q.Episode.replaceDB(db),
		Genre:                q.Genre.replaceDB(db),
		Keyword:              q.Keyword.replaceDB(db),
		Movie:                q.Movie.replaceDB(db),
		Season:               q.Season.replaceDB(db),
		Series:               q.Series.replaceDB(db),
		Studio:               q.Studio.replaceDB(db),
		User:                 q.User.replaceDB(db),
		VideoActorMapping:    q.VideoActorMapping.replaceDB(db),
		VideoGenreMapping:    q.VideoGenreMapping.replaceDB(db),
		VideoKeywordMapping:  q.VideoKeywordMapping.replaceDB(db),
		VideoStudioMapping:   q.VideoStudioMapping.replaceDB(db),
		VideoSubtitleMapping: q.VideoSubtitleMapping.replaceDB(db),
		VideoUserMapping:     q.VideoUserMapping.replaceDB(db),
	}
}

type queryCtx struct {
	Actor                *actorDo
	AppVersion           *appVersionDo
	Episode              *episodeDo
	Genre                *genreDo
	Keyword              *keywordDo
	Movie                *movieDo
	Season               *seasonDo
	Series               *seriesDo
	Studio               *studioDo
	User                 *userDo
	VideoActorMapping    *videoActorMappingDo
	VideoGenreMapping    *videoGenreMappingDo
	VideoKeywordMapping  *videoKeywordMappingDo
	VideoStudioMapping   *videoStudioMappingDo
	VideoSubtitleMapping *videoSubtitleMappingDo
	VideoUserMapping     *videoUserMappingDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		Actor:                q.Actor.WithContext(ctx),
		AppVersion:           q.AppVersion.WithContext(ctx),
		Episode:              q.Episode.WithContext(ctx),
		Genre:                q.Genre.WithContext(ctx),
		Keyword:              q.Keyword.WithContext(ctx),
		Movie:                q.Movie.WithContext(ctx),
		Season:               q.Season.WithContext(ctx),
		Series:               q.Series.WithContext(ctx),
		Studio:               q.Studio.WithContext(ctx),
		User:                 q.User.WithContext(ctx),
		VideoActorMapping:    q.VideoActorMapping.WithContext(ctx),
		VideoGenreMapping:    q.VideoGenreMapping.WithContext(ctx),
		VideoKeywordMapping:  q.VideoKeywordMapping.WithContext(ctx),
		VideoStudioMapping:   q.VideoStudioMapping.WithContext(ctx),
		VideoSubtitleMapping: q.VideoSubtitleMapping.WithContext(ctx),
		VideoUserMapping:     q.VideoUserMapping.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
